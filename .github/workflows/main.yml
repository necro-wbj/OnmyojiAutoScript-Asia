name: Auto Rebase Upstream Dev

on:
  schedule:
    - cron: "0 * * * *"      # æ¯ 5 åˆ†é˜
  workflow_dispatch: {}
  push:
    branches: [ main ]
    paths-ignore:
      - ".github/**"
      - "docs/**"
      - "README.md"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

jobs:
  sync-upstream:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout (full)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Git setup (identity & safety)
        run: |
          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          git config core.autocrlf false

      - name: Add upstream and fetch
        run: |
          set -e
          git remote remove upstream 2>/dev/null || true
          git remote add upstream https://github.com/runhey/OnmyojiAutoScript.git
          git fetch --prune origin
          git fetch --prune upstream

      # è§£æä¾†æºï¼šæœ‰ upstream/dev ç”¨å®ƒï¼Œå¦å‰‡å›é€€åˆ°è‡ªå·±çš„ main
      - name: Resolve upstream ref (dev or origin/main)
        id: resolve
        shell: bash
        run: |
          set -e
          TARGET_BRANCH="dev"
          if git ls-remote --heads upstream "$TARGET_BRANCH" | grep -q "refs/heads/$TARGET_BRANCH"; then
            UP_REF="upstream/${TARGET_BRANCH}"
            REASON="found-branch"
          else
            UP_REF="origin/main"
            REASON="fallback-origin-main"
          fi

          git fetch --prune origin
          if [[ "$UP_REF" == upstream/* ]]; then git fetch --prune upstream; fi

          UP_TIP=$(git rev-parse --short "${UP_REF}")
          ORI_TIP=$(git rev-parse --short origin/main)
          read BEHIND AHEAD < <(git rev-list --left-right --count origin/main..."${UP_REF}" | awk '{print $1" "$2}')

          echo "up_ref=${UP_REF}"           >> $GITHUB_OUTPUT
          echo "reason=${REASON}"           >> $GITHUB_OUTPUT
          echo "upstream_tip=${UP_TIP}"     >> $GITHUB_OUTPUT
          echo "origin_tip=${ORI_TIP}"      >> $GITHUB_OUTPUT
          echo "ahead=${AHEAD}"             >> $GITHUB_OUTPUT
          echo "behind=${BEHIND}"           >> $GITHUB_OUTPUT

          echo "[LOG] Using upstream ref: ${UP_REF} (${REASON})"
          echo "[LOG] origin/main tip:  ${ORI_TIP}"
          echo "[LOG] ${UP_REF} tip:     ${UP_TIP}"
          echo "[LOG] AHEAD=${AHEAD}, BEHIND=${BEHIND}"

      - name: Exit early if no changes from upstream
        id: earlycheck
        shell: bash
        run: |
          set -e
          UP_REF="${{ steps.resolve.outputs.up_ref }}"
          if git diff --quiet origin/main.."${UP_REF}"; then
            echo "no_changes=true" >> $GITHUB_OUTPUT
            echo "[LOG] No changes detected between origin/main and ${UP_REF}. Exit for PR creation."
          else
            echo "no_changes=false" >> $GITHUB_OUTPUT
            echo "[LOG] Changes detected from ${UP_REF}. PR will be created/updated."
          fi

      # ç”¨ archive è§£å£“è¦†å¯«å·¥ä½œæ¨¹ï¼ˆä¸ pushï¼Œäº¤çµ¦ CPR å»ºåˆ†æ”¯/PRï¼‰
      - name: Materialize upstream ref via archive (no push; keep local on both-changed)
        if: steps.earlycheck.outputs.no_changes != 'true'
        shell: bash
        run: |
          set -e
          UP_REF="${{ steps.resolve.outputs.up_ref }}"
      
          # â˜… ä¸€å®šåœåœ¨ mainï¼ˆCPR æœƒ reset åˆ° origin/mainï¼‰
          git checkout -B main origin/main
      
          # 0) ç®— merge-baseï¼ˆç”¨ä¾†åˆ¤æ–·é›™æ–¹æ˜¯å¦éƒ½æœ‰æ”¹ï¼‰
          BASE=$(git merge-base origin/main "${UP_REF}")
          echo "[LOG] merge-base: ${BASE}"
      
          # 1) ä¹¾æ·¨å·¥ä½œæ¨¹
          git rm -r -q --cached . || true
          git clean -fdqx || true
      
          # 2) å°‡ä¸Šæ¸¸å…§å®¹å±•é–‹åˆ°å·¥ä½œæ¨¹ï¼ˆæ’é™¤ .githubï¼Œé¿å… workflows æ¬Šé™å•é¡Œï¼‰
          echo "[LOG] Archiving ${UP_REF} â†’ extracting (excluding .github)..."
          git archive --format=tar "${UP_REF}" | tar -x -m --exclude=".github" --exclude="./.github"
      
          # 3) å›ºå®šç”¨æœ¬åœ°ï¼ˆorigin/mainï¼‰çš„ .gitattributesï¼ˆè®“ eol/å±¬æ€§åœ¨ add æ™‚ç”Ÿæ•ˆï¼‰
          #    ä¹ŸæŠŠ .github é‚„åŸæˆæœ¬åœ°ï¼ˆé¿å…åŒæ­¥ä¸Šæ¸¸ workflowsï¼‰
          git checkout origin/main -- .gitattributes .github || true
      
          # 4) è¨ˆç®—ã€Œé›™æ–¹éƒ½æœ‰æ”¹ã€çš„æª”æ¡ˆé›†åˆï¼ˆç›¸å° merge-baseï¼‰
          #    left = æœ¬åœ°æ”¹å‹• (BASE..origin/main)ï¼Œright = ä¸Šæ¸¸æ”¹å‹• (BASE..UP_REF)
          #    æˆ‘å€‘åªé—œå¿ƒç‰¹å®šæ¸…å–®/å‹åˆ¥ï¼Œå…©é‚Šéƒ½æœ‰æ”¹æ‰ä¿ç•™æœ¬åœ°ã€‚
          mapfile -t LEFT < <(git diff --name-only --diff-filter=ACMR "${BASE}..origin/main")
          mapfile -t RIGHT < <(git diff --name-only --diff-filter=ACMR "${BASE}..${UP_REF}")
      
          # ä½ è¦ã€Œé›™æ–¹éƒ½æœ‰æ”¹æ™‚ä¿ç•™æœ¬åœ°ã€çš„æ¸…å–®ï¼ˆå¯è‡ªè¡Œå¢ä¿®ï¼‰
          PROTECT_LIST=(
            ".gitattributes"
            ".gitignore"
            "README.md"
          )
          # å‹åˆ¥/ç›®éŒ„è¦å‰‡ï¼ˆglobï¼‰ï¼Œé›™æ–¹éƒ½æœ‰æ”¹æ‰ä¿ç•™æœ¬åœ°
          PROTECT_GLOBS=(
            "assets/**"
            "*.png"
            "*.jpg"
            "*.json"
            "*.yaml"
            "*.yml"
            "*.ini"
            "*.xml"
            "*.txt"
          )
      
          # å»ºç«‹ right çš„æŸ¥è¡¨ï¼ŒåŠ é€Ÿæ¯”å°
          declare -A RIGHT_SET
          for p in "${RIGHT[@]}"; do RIGHT_SET["$p"]=1; done
      
          keep_local=()
      
          # å…ˆè™•ç†æ˜ç¢ºæª”å
          for p in "${PROTECT_LIST[@]}"; do
            # è‹¥æ­¤æª”å…©é‚Šéƒ½æœ‰æ”¹ï¼Œä¿ç•™æœ¬åœ°
            if printf '%s\n' "${LEFT[@]}" | grep -Fxq "$p" && [[ -n "${RIGHT_SET[$p]}" ]]; then
              keep_local+=("$p")
            fi
          done
      
          # å†è™•ç†å‹åˆ¥/ç›®éŒ„è¦å‰‡ï¼ˆç”¨ bash çš„ [[ $f == glob ]]ï¼‰
          for f in "${LEFT[@]}"; do
            [[ -z "${RIGHT_SET[$f]}" ]] && continue  # å³å´ç„¡æ”¹å‹•å°±è·³é
            for g in "${PROTECT_GLOBS[@]}"; do
              if [[ "$f" == $g ]]; then
                keep_local+=("$f")
                break
              fi
            done
          done
      
          # 5) å°æ–¼éœ€è¦ä¿ç•™æœ¬åœ°çš„æª”æ¡ˆï¼ŒæŠŠå‰›æ‰è§£å‡ºçš„ä¸Šæ¸¸ç‰ˆæœ¬è¦†è“‹å›ã€Œæœ¬åœ°ç‰ˆæœ¬ã€
          #    ä¹Ÿå°±æ˜¯å¾ origin/main é‚„åŸé€™äº›æª”æ¡ˆ
          if [[ ${#keep_local[@]} -gt 0 ]]; then
            echo "[LOG] Keep-local (both changed) files:"
            printf ' - %s\n' "${keep_local[@]}"
            git checkout origin/main -- "${keep_local[@]}" || true
          else
            echo "[LOG] Keep-local set is empty."
          fi
      
          # 6) å…¨é‡åŠ å…¥ç´¢å¼•ï¼ˆ.gitattributes å·²æ˜¯æœ¬åœ°ç‰ˆï¼Œæ­¤æ™‚ EOL/æ–‡æœ¬å±¬æ€§ç”Ÿæ•ˆï¼‰
          git add -A
      
          echo "[LOG] Staged summary (vs origin/main):"
          git --no-pager diff --cached --stat || true



      - name: Create / Update PR
        if: steps.earlycheck.outputs.no_changes != 'true'
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          branch: sync/upstream-dev
          base: main
          title: >-
            Auto sync ${{ steps.resolve.outputs.up_ref }} â†’ main
          commit-message: >-
            chore(sync): mirror ${{ steps.resolve.outputs.up_ref }} into main
          body: |
            Automated sync from **${{ steps.resolve.outputs.up_ref }}** to **main**.
            - upstream ref: `${{ steps.resolve.outputs.up_ref }}`
            - reason: `${{ steps.resolve.outputs.reason }}`  (found-branch / fallback-origin-main)
            - upstream tip: `${{ steps.resolve.outputs.upstream_tip }}`
            - origin tip:   `${{ steps.resolve.outputs.origin_tip }}`
            - ahead:  `${{ steps.resolve.outputs.ahead }}`
            - behind: `${{ steps.resolve.outputs.behind }}`
          labels: "chore,auto-sync"
          delete-branch: false

      # æœ‰ PR â†’ è²¼ PR é€£çµ
      - name: Notify Discord (PR created/updated)
        if: steps.earlycheck.outputs.no_changes != 'true' && steps.cpr.outputs.pull-request-operation != 'none'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          PR_URL: ${{ steps.cpr.outputs.pull-request-url }}
          OP: ${{ steps.cpr.outputs.pull-request-operation }}
        run: |
          set -e
          MSG=$(cat <<EOF
          ğŸ”„ **Auto sync ${{ steps.resolve.outputs.up_ref }} â†’ main** (${OP})
          PR: ${PR_URL}
          EOF
          )
          curl -sS -X POST "$DISCORD_WEBHOOK" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg content "$MSG" '{content: $content}')"

      # ä»»ä¸€æ­¥é©Ÿå¤±æ•— â†’ è²¼ Run é€£çµ
      - name: Notify Discord (run failed)
        if: failure()
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK }}
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -e
          MSG=$(cat <<EOF
          âŒ **Auto sync failed**
          Run: ${RUN_URL}
          EOF
          )
          curl -sS -X POST "$DISCORD_WEBHOOK" \
            -H 'Content-Type: application/json' \
            -d "$(jq -n --arg content "$MSG" '{content: $content}')"
